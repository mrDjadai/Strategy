unit DataTypes;

interface
 uses
  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Objects;

Type

Vector2 = Record
  x, y : integer;
End;

  TCharacter = class
    private
      var
        img : TImage;

    destructor OnDestroy();


    public
      var
        sprite : string;
        pos : vector2;
        hp : integer;
        speed : integer;
        armor : integer;

        procedure ReDraw();
  end;

TCellType = (cBlocked, cDefault, cDifficult);


TCellData = class
  private
    procedure OnClick(sender : Tobject);
    procedure SetImage(im : TImage);
    function GetImage() : TImage;
    destructor OnDestroy();

    var
      img : TImage;

  public
    var
      sprite : string;
      decardPos : Vector2;
      cType : TCellType;
      character : TCharacter;

  procedure ReDraw();

  property Image: TImage read GetImage write SetImage;

End;



implementation

procedure DrawOutline(Image: TImage; BorderColor: TAlphaColor; BorderWidth: Integer);
var
  Bitmap: TBitmap;
  DestRect, BorderRect: TRectF;
  BitmapData : TBitmapData;
  PixelRec: TAlphaColorRec;
  PixelColor: TAlphaColor;

begin
  Bitmap := TBitmap.Create;
  Bitmap.SetSize(Image.Bitmap.Width + 2 * BorderWidth, Image.Bitmap.Height + 2 * BorderWidth);
  Bitmap.Canvas.BeginScene;

  BorderRect := RectF(0, 0,
                        Bitmap.Width, Bitmap.Height);

  DestRect := RectF(BorderWidth, BorderWidth,
                        Bitmap.Width - BorderWidth, Bitmap.Height - BorderWidth);

  Bitmap.Canvas.DrawBitmap(Image.Bitmap,
                               RectF(0, 0, Image.Bitmap.Width, Image.Bitmap.Height),
                               BorderRect,
                               1, True);

  if Bitmap.Map(TMapAccess.ReadWrite, BitmapData) then
    for var Y := 0 to Bitmap.Height - 1 do
      for var X := 0 to Bitmap.Width - 1 do
      begin
        PixelColor := BitmapData.GetPixel(X, Y);
        PixelRec := TAlphaColorRec(PixelColor);
        if true then
        begin
          PixelRec.R := TAlphaColorRec(BorderColor).R;
          PixelRec.G := TAlphaColorRec(BorderColor).G;
          PixelRec.B := TAlphaColorRec(BorderColor).B;
        end;
      end;
    Bitmap.Unmap(BitmapData);


 { Bitmap.Canvas.DrawBitmap(Image.Bitmap,
                               RectF(0, 0, Image.Bitmap.Width, Image.Bitmap.Height),
                               DestRect,
                               1, True);        }

  Bitmap.Canvas.EndScene;

  Image.Bitmap.Assign(Bitmap);
  Bitmap.Free;
end;

procedure TCellData.ReDraw();
var cBitmap : TBitMap;
begin
  img.Bitmap.LoadFromFile(ExtractFilePath(ParamStr(0)) + 'Resourses\Sprites\' + sprite + '.png');

  if character <> nil then
    character.ReDraw();
end;

procedure TCellData.OnClick(sender: TObject);
begin
  WriteLn('clicked    ' + sprite);            //тест

  if True then                                // если режим предварительной расстановки
  begin
    var c : TCharacter;
    c := TCharacter.Create;
    c.sprite := 'pers';
    c.pos := decardPos;
    character := c;

    var myImage : TImage;
    myImage := TImage.Create(TComponent(Sender).Owner);
    myImage.Parent := TControl(Sender).Parent;

    MyImage.Position := img.Position;
    MyImage.Height := img.Height;
    MyImage.BringToFront();
    c.img := myImage;
    ReDraw();
  end;

end;

procedure TCellData.SetImage(im: TImage);
begin
  if img <> nil then
    img.OnClick := nil;
  img := im;
  img.OnClick := OnClick;
end;

function TCellData.GetImage: TImage;
begin
  Result := img;
end;


destructor TCharacter.OnDestroy();
begin
  img.Free;
  inherited Destroy;
end;


destructor TCellData.OnDestroy();
begin
  img.Free;
  character.Free;
  inherited Destroy;
end;


procedure TCharacter.ReDraw();
begin
  img.Bitmap.LoadFromFile(ExtractFilePath(ParamStr(0)) + 'Resourses\Sprites\' + sprite + '.png');
  DrawOutline(img, TAlphaColors.Yellow, 50);
end;

end.
